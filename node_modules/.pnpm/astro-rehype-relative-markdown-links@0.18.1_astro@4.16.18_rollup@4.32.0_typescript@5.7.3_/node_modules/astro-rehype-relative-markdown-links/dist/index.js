// src/plugin.ts
import { visit } from "unist-util-visit";
import * as path2 from "path";
import { default as debugFn } from "debug";

// src/utils.ts
import path from "path";
import { readFileSync, statSync } from "fs";
import { slug as githubSlug } from "github-slugger";
import { z } from "zod";
import { asError } from "catch-unknown";
import isAbsoluteUrl from "is-absolute-url";
import matter from "gray-matter";
var validMarkdownExtensions = [".md", ".mdx"];
var isWindows = typeof process !== "undefined" && process.platform === "win32";
var windowsSlashRE = /\\/g;
function slash(npath, sep) {
  return npath.replace(windowsSlashRE, sep);
}
function normalizePath(npath) {
  return path.posix.normalize(isWindows ? slash(npath, path.posix.sep) : npath);
}
var FILE_PATH_SEPARATOR = path.sep;
var URL_PATH_SEPARATOR = "/";
var PATH_SEGMENT_EMPTY = "";
var replaceExt = (npath, ext) => {
  if (typeof npath !== "string" || npath.length === 0) {
    return npath;
  }
  return npath.replace(new RegExp(path.extname(npath) + "$"), ext);
};
var isValidRelativeLink = (link) => {
  if (!link) {
    return false;
  }
  if (isAbsoluteUrl(link)) {
    return false;
  }
  if (path.isAbsolute(link)) {
    return false;
  }
  if (!validMarkdownExtensions.includes(path.extname(link))) {
    return false;
  }
  return true;
};
var isValidFile = (path3) => {
  if (!path3) {
    return false;
  }
  try {
    return statSync(path3).isFile();
  } catch (err) {
    const error = asError(err);
    if ("code" in error && error.code === "ENOENT") {
      return false;
    }
    throw error;
  }
};
var splitPathFromQueryAndFragment = (url) => {
  const indexQuery = url.indexOf("?");
  const indexHash = url.indexOf("#");
  if (indexQuery === -1 && indexHash === -1) {
    return [decodeURI(url), null];
  }
  let firstCharacterIndex;
  if (indexQuery !== -1 && indexHash === -1) {
    firstCharacterIndex = indexQuery;
  } else if (indexQuery === -1 && indexHash !== -1) {
    firstCharacterIndex = indexHash;
  } else {
    firstCharacterIndex = indexQuery < indexHash ? indexQuery : indexHash;
  }
  const splitUrl = url.substring(0, firstCharacterIndex);
  const splitQueryStringAndHash = url.substring(firstCharacterIndex);
  return [decodeURI(splitUrl), splitQueryStringAndHash];
};
var normaliseAstroOutputPath = (initialPath, collectionOptions) => {
  const buildPath = () => {
    if (!collectionOptions.base) {
      return initialPath;
    }
    if (collectionOptions.base.startsWith(URL_PATH_SEPARATOR)) {
      return path.join(collectionOptions.base, initialPath);
    }
    return URL_PATH_SEPARATOR + path.join(collectionOptions.base, initialPath);
  };
  if (!initialPath) {
    return initialPath;
  }
  return normalizePath(buildPath());
};
var generateSlug = (pathSegments) => {
  return pathSegments.map((segment) => githubSlug(segment)).join(URL_PATH_SEPARATOR).replace(/\/index$/, "");
};
var resolveSlug = (generatedSlug, frontmatterSlug) => {
  return z.string().default(generatedSlug).parse(frontmatterSlug);
};
var applyTrailingSlash = (origUrl, resolvedUrl, trailingSlash = "ignore") => {
  const hasTrailingSlash = resolvedUrl.endsWith(URL_PATH_SEPARATOR);
  if (trailingSlash === "always") {
    return hasTrailingSlash ? resolvedUrl : resolvedUrl + URL_PATH_SEPARATOR;
  }
  if (trailingSlash === "never") {
    return hasTrailingSlash ? resolvedUrl.slice(0, -1) : resolvedUrl;
  }
  const hadTrailingSlash = origUrl.endsWith(URL_PATH_SEPARATOR);
  if (hadTrailingSlash && !hasTrailingSlash) {
    return resolvedUrl + URL_PATH_SEPARATOR;
  }
  if (!hadTrailingSlash && hasTrailingSlash) {
    return resolvedUrl.slice(0, -1);
  }
  return resolvedUrl;
};
function shouldProcessFile(npath) {
  return !npath.split(path.sep).some((p) => p && p.startsWith("_"));
}
var matterCache = {};
var matterCacheEnabled = process.env.ARRML_MATTER_CACHE_DISABLE !== "true";
function getMatter(npath) {
  const readMatter = () => {
    const content = readFileSync(npath);
    const { data: frontmatter } = matter(content);
    if (matterCacheEnabled) {
      matterCache[npath] = frontmatter;
    }
    return frontmatter;
  };
  return matterCache[npath] || readMatter();
}
function resolveCollectionBase(collectionOptions) {
  return collectionOptions.collectionBase === false ? PATH_SEGMENT_EMPTY : URL_PATH_SEPARATOR + collectionOptions.collectionName;
}

// src/options.ts
import { z as z2 } from "zod";
var CollectionBase = z2.union([z2.literal("name"), z2.literal(false)]);
var CollectionConfigSchema = z2.object({
  /**
   * Override the top-level {@link Options#collectionBase collectionBase} option for this collection.
   */
  base: CollectionBase.optional(),
  /**
   * Override the name of the collection from disk.
   *
   * Use this option when your collection page path does not correspond to the name of the collection on disk (ex. `src/content/docs/reference.md` resolves to a page path of `/my-docs/reference`).
   *
   * When not specified, the name of the collection from disk will be used where applicable.
   */
  name: z2.string().optional()
});
var OptionsSchema = z2.object({
  /**
   * Set the directory that Astro will read your site from.
   *
   * The value can be either an absolute file system path or a path relative to the project root.
   * @default `./src`
   * @see {@link https://docs.astro.build/en/reference/configuration-reference/#srcdir}
   * @example
   * ```js
   * {
   *   srcDir: './www'
   * }
   * ```
   */
  srcDir: z2.string().default("./src"),
  /**
   * Set how the base segment of the URL path to the referenced markdown file should be derived:
   *   - `"name"` - Apply the name on disk of the content collection (ex. `./guides/my-guide.md` referenced from `./resources/my-reference.md` in the content collection `docs` would resolve to the path `/docs/guides/my-guide`)
   *   - `false` - Do not apply a base (ex. `./guides/my-guide.md` referenced from `./resources/my-reference.md` in the content collection `docs` would resolve to the path `/guides/my-guide`)
   *
   * Use `false` when you are treating your content collection as if it were located in the site root (ex: `src/pages`). In most scenarios, you should set this value to `"name"` or not
   * set this value and the default of `"name"` will be used.
   *
   * Note that this is a top-level option and will apply to all content collections.  If you have multiple content collections and want the behavior to be different on a per content collection basis, add the collection(s) to
   * the {@link Options#collections collections} option and provide a value for the {@link CollectionConfig#base base} property.
   * @default `"name"`
   * @see {@link Options#collections collections}
   * @example
   * ```js
   * {
   *   // Do not apply a base segment to the transformed URL path
   *   collectionBase: false
   * }
   * ```
   */
  collectionBase: CollectionBase.default("name"),
  /**
   * Specify a mapping of collections where the key is the name of a collection on disk and the value is an object of collection specific configuration which will override any top-level
   * configuration where applicable.
   * @default `{}`
   * @see {@link CollectionConfig}
   * @example
   * ```js
   * {
   *   // Do not apply a base segment to the transformed URL for the collection `docs`
   *   collections: {
   *     docs: {
   *       base: false
   *     }
   *   }
   * }
   * ```
   */
  collections: z2.record(CollectionConfigSchema).default({}),
  /**
   * The base path to deploy to. Astro will use this path as the root for your pages and assets both in development and in production build.
   * @see {@link https://docs.astro.build/en/reference/configuration-reference/#base}
   * @example
   * In the example below, `astro dev` will start your server at `/docs`.
   *
   * ```js
   * {
   *   base: '/docs'
   * }
   * ```
   */
  base: z2.string().optional(),
  /**
   * Allows you to control the behavior for how trailing slashes should be handled on transformed urls:
   *   - `"always"` - Ensure urls always end with a trailing slash regardless of input
   *   - `"never"` - Ensure urls never end with a trailing slash regardless of input
   *   - `"ignore"` - Do not modify the url, trailing slash behavior will be determined by the file url itself or a custom slug if present.
   *
   * When set to `"ignore"` (the default), the following will occur:
   *   - If there is not a custom slug on the target file, the markdown link itself will determine if there is a trailing slash.
   *       - `[Example](./my-doc.md/)` will result in a trailing slash
   *       - `[Example](./my-doc.md)` will not result in a trailing slash
   *   - If there is a custom slug on the target file, the custom slug determines if there is a trailing slash.
   *       - `slug: my-doc/` will result in a trailing slash
   *       - `slug: my-doc` will not result in a trailing slash
   * @default `"ignore"`
   * @see {@link https://docs.astro.build/en/reference/configuration-reference/#trailingslash}
   * @example
   * ```js
   * {
   *   // Use `always` mode
   *   trailingSlash: "always"
   * }
   * ```
   */
  trailingSlash: z2.union([z2.literal("ignore"), z2.literal("always"), z2.literal("never")]).default("ignore")
});
var validateOptions = (options) => {
  const result = OptionsSchema.safeParse(options || {});
  if (!result.success) {
    throw result.error;
  }
  return result.data;
};
var mergeCollectionOptions = (collectionName, options) => {
  const config = options.collections[collectionName] || {};
  const { base = options.collectionBase, name = collectionName } = config;
  return {
    ...options,
    collectionBase: base,
    collectionName: name
  };
};

// src/plugin.ts
var debug = debugFn("astro-rehype-relative-markdown-links");
var astroRehypeRelativeMarkdownLinks = (opts) => {
  const options = validateOptions(opts);
  return (tree, file) => {
    visit(tree, "element", (node) => {
      if (node.type !== "element" || node.tagName !== "a" || typeof node.properties.href !== "string" || !node.properties.href) {
        return;
      }
      const nodeHref = node.properties.href;
      const [urlPathPart, urlQueryStringAndFragmentPart] = splitPathFromQueryAndFragment(nodeHref);
      if (!isValidRelativeLink(urlPathPart)) {
        return;
      }
      const currentFile = file.history[0];
      if (!currentFile) {
        return;
      }
      const currentFileParsed = path2.parse(currentFile);
      const currentFileDirectory = currentFileParsed.dir;
      const urlFilePath = path2.resolve(currentFileDirectory, urlPathPart);
      if (!isValidFile(urlFilePath)) {
        return;
      }
      const { slug: frontmatterSlug } = getMatter(urlFilePath);
      const contentDir = path2.resolve(options.srcDir, "content");
      const trailingSlashMode = options.trailingSlash;
      const relativeToContentPath = path2.relative(contentDir, urlFilePath);
      if (!shouldProcessFile(relativeToContentPath)) {
        return;
      }
      const collectionName = path2.dirname(relativeToContentPath).split(FILE_PATH_SEPARATOR)[0];
      if (!collectionName) {
        return;
      }
      const collectionOptions = mergeCollectionOptions(collectionName, options);
      if (collectionName === ".." || collectionOptions.collectionBase !== false && collectionName === ".") {
        return;
      }
      const collectionDir = path2.join(contentDir, collectionName);
      const relativeToCollectionPath = path2.relative(
        collectionDir,
        urlFilePath
      );
      const withoutFileExt = replaceExt(relativeToCollectionPath, "");
      const pathSegments = withoutFileExt.split(FILE_PATH_SEPARATOR);
      const generatedSlug = generateSlug(pathSegments);
      const resolvedSlug = resolveSlug(generatedSlug, frontmatterSlug);
      const resolvedCollectionBase = resolveCollectionBase(collectionOptions);
      const resolvedUrl = [resolvedCollectionBase, resolvedSlug].join(
        URL_PATH_SEPARATOR
      );
      let webPathFinal = applyTrailingSlash(
        (collectionOptions.collectionBase === false && frontmatterSlug === PATH_SEGMENT_EMPTY ? URL_PATH_SEPARATOR : frontmatterSlug) || urlPathPart,
        resolvedUrl,
        trailingSlashMode
      );
      if (urlQueryStringAndFragmentPart) {
        webPathFinal += urlQueryStringAndFragmentPart;
      }
      webPathFinal = normaliseAstroOutputPath(webPathFinal, collectionOptions);
      debug("--------------------------------------");
      debug("Base path                            : %s", options.base);
      debug("SrcDir                               : %s", options.srcDir);
      debug("ContentDir                           : %s", contentDir);
      debug("CollectionDir                        : %s", collectionDir);
      debug("Collection Name from Disk            : %s", collectionName);
      debug(
        "Resolved Collection Name Option      : %s",
        collectionOptions.collectionName
      );
      debug(
        "Resolved Collection Base Option      : %s",
        collectionOptions.collectionBase
      );
      debug(
        "Resolved Collection Base             : %s",
        resolvedCollectionBase
      );
      debug("TrailingSlashMode                    : %s", trailingSlashMode);
      debug("md/mdx AST Current File              : %s", currentFile);
      debug("md/mdx AST Current File Dir          : %s", currentFileDirectory);
      debug("md/mdx AST href full                 : %s", nodeHref);
      debug("md/mdx AST href path                 : %s", urlPathPart);
      debug(
        "md/mdx AST href qs and/or hash       : %s",
        urlQueryStringAndFragmentPart
      );
      debug("URL file                             : %s", urlFilePath);
      debug("URL file relative to content path    : %s", relativeToContentPath);
      debug(
        "URL file relative to collection path : %s",
        relativeToCollectionPath
      );
      debug("URL file custom slug                 : %s", frontmatterSlug);
      debug("URL file generated slug              : %s", generatedSlug);
      debug("URL file resolved slug               : %s", resolvedSlug);
      debug("Final URL                            : %s", webPathFinal);
      node.properties.href = webPathFinal;
    });
  };
};
var plugin_default = astroRehypeRelativeMarkdownLinks;
export {
  plugin_default as default
};
