import { defu } from "defu";
import { visit } from "unist-util-visit";
export const defaultOptions = {
    root: (callout) => ({
        tagName: callout.isFoldable ? "details" : "div",
        properties: {
            dataCallout: true,
            dataCalloutType: formatForAttribute(callout.type),
            open: callout.defaultFolded === undefined ? false : !callout.defaultFolded,
        },
    }),
    title: (callout) => ({
        tagName: callout.isFoldable ? "summary" : "div",
        properties: {
            dataCalloutTitle: true,
        },
    }),
    titleInner: (callout, options) => options.icon(callout) == null && options.foldIcon(callout) == null
        ? undefined
        : {
            tagName: "div",
            properties: {
                dataCalloutTitleInner: true,
            },
        },
    icon: () => undefined,
    foldIcon: () => undefined,
    body: () => ({
        tagName: "div",
        properties: {
            dataCalloutBody: true,
        },
    }),
    callouts: null,
    onUnknownCallout: () => undefined,
};
const initOptions = (options) => {
    const defaultedOptions = defu(options, defaultOptions);
    return Object.fromEntries(Object.entries(defaultedOptions).map(([key, value]) => {
        if (["root", "title", "titleInner", "body", "icon", "foldIcon"].includes(key) &&
            typeof value !== "function") {
            return [key, () => value];
        }
        return [key, value];
    }));
};
/**
 * A remark plugin to parse callout syntax.
 */
export const remarkCallout = (_options) => {
    const options = initOptions(_options);
    return (tree, file) => {
        visit(tree, "blockquote", (node) => {
            const paragraphNode = node.children.at(0);
            if (paragraphNode == null || paragraphNode.type !== "paragraph")
                return;
            // Skip if the first line is empty
            if (node.position?.start.line !== paragraphNode.position?.start.line) {
                return;
            }
            const calloutTypeTextNode = paragraphNode.children.at(0);
            if (calloutTypeTextNode == null || calloutTypeTextNode.type !== "text") {
                return;
            }
            // Parse callout syntax
            // e.g. "[!note] title"
            const [calloutTypeText, ...calloutBodyText] = calloutTypeTextNode.value.split("\n");
            const calloutData = parseCallout(calloutTypeText);
            if (calloutData == null)
                return;
            if (options.callouts != null &&
                !options.callouts.includes(calloutData.type)) {
                const newCallout = options.onUnknownCallout(calloutData, file);
                if (newCallout == null)
                    return;
                calloutData.type = newCallout.type;
                calloutData.isFoldable = newCallout.isFoldable;
                if (newCallout.title != null) {
                    calloutData.title = newCallout.title;
                }
            }
            // Generate callout root node
            node.data = {
                ...node.data,
                hName: options.root(calloutData).tagName,
                hProperties: {
                    // @ts-ignore error TS2339: Property 'hProperties' does not exist on type 'BlockquoteData'.
                    ...node.data?.hProperties,
                    ...options.root(calloutData).properties,
                },
            };
            // Generate callout body node
            const bodyNode = [
                {
                    type: "paragraph",
                    children: [],
                },
                ...node.children.splice(1),
            ];
            if (bodyNode[0].type !== "paragraph")
                return; // type check
            if (calloutBodyText.length > 0) {
                bodyNode[0].children.push({
                    type: "text",
                    value: calloutBodyText.join("\n"),
                });
            }
            // Generate callout title node
            const titleNode = {
                type: options.titleInner(calloutData, options) == null
                    ? "paragraph"
                    : "blockquote",
                data: {
                    hName: options.title(calloutData).tagName,
                    hProperties: {
                        ...options.title(calloutData).properties,
                    },
                },
                children: [],
            };
            // Add icon node before the title text
            const iconNode = options.icon(calloutData);
            if (iconNode != null) {
                titleNode.children.push(toHtml(iconNode));
            }
            // Add title text node
            const titleInnerNode = {
                type: "paragraph",
                data: {
                    hName: options.titleInner(calloutData, options)?.tagName,
                    hProperties: options.titleInner(calloutData, options)?.properties,
                },
                children: [],
            };
            if (calloutData.title != null) {
                titleInnerNode.children.push({
                    type: "text",
                    value: calloutData.title,
                });
            }
            if (calloutBodyText.length <= 0) {
                for (const [i, child] of paragraphNode.children.slice(1).entries()) {
                    // Add all nodes after the break as callout body
                    if (child.type === "break") {
                        titleInnerNode.children.push(child); // Add the line break as callout title
                        bodyNode[0].children.push(...paragraphNode.children.slice(i + 1 + 1)); // +1 for the callout type node, +1 for the break
                        break;
                    }
                    // All inline node before the line break is added as callout title
                    if (child.type !== "text") {
                        titleInnerNode.children.push(child);
                        continue;
                    }
                    // Add the part before the line break as callout title and the part after as callout body
                    const [titleText, ...bodyTextLines] = child.value.split("\n");
                    if (titleText) {
                        // Add the part before the line break as callout title
                        titleInnerNode.children.push({
                            type: "text",
                            value: titleText,
                        });
                    }
                    if (bodyTextLines.length > 0) {
                        // Add the part after the line break as callout body
                        if (bodyNode[0].type !== "paragraph")
                            return;
                        bodyNode[0].children.push({
                            type: "text",
                            value: bodyTextLines.join("\n"),
                        });
                        // Add all nodes after the current node as callout body
                        bodyNode[0].children.push(...paragraphNode.children.slice(i + 2));
                        break;
                    }
                }
            }
            else {
                // Add all nodes after the current node as callout body
                bodyNode[0].children.push(...paragraphNode.children.slice(1));
            }
            if (titleNode.type === "paragraph")
                titleNode.children.push(...titleInnerNode.children);
            else
                titleNode.children.push(titleInnerNode);
            // Add fold icon node after the title text
            const foldIconNode = options.foldIcon(calloutData);
            if (foldIconNode != null) {
                titleNode.children.push(toHtml(foldIconNode));
            }
            // Add body and title to callout root node children
            node.children = [titleNode];
            if (bodyNode.length > 1 || bodyNode[0].children.length > 0) {
                node.children.push({
                    type: "blockquote",
                    data: {
                        hName: options.body(calloutData).tagName,
                        hProperties: {
                            ...options.body(calloutData).properties,
                        },
                    },
                    children: bodyNode,
                });
            }
        });
    };
};
/**
 * @example
 * ```
 * const callout = parseCallout("[!info]");  // { type: "info", isFoldable: false, title: undefined }
 * const callout = parseCallout("[!info");   // undefined
 * ```
 */
export const parseCallout = (text) => {
    if (text == null)
        return;
    const match = text.match(/^\[!(?<type>[^\]]+)?\](?<isFoldable>[+-])?(?: (?<title>.*))?$/);
    if (match?.groups?.type == null)
        return undefined;
    const callout = {
        type: match.groups.type,
        isFoldable: match.groups.isFoldable != null,
    };
    if (match.groups.isFoldable != null) {
        callout.defaultFolded = match.groups.isFoldable === "-";
    }
    if (match.groups.title != null) {
        callout.title = match.groups.title;
    }
    else {
        callout.title = capitalize(callout.type);
    }
    return callout;
};
export const toHtml = (from) => {
    if (typeof from === "string") {
        return {
            type: "html",
            value: from,
        };
    }
    if (typeof from.children === "string") {
        return {
            type: "html",
            data: {
                hName: from.tagName,
                hProperties: from.properties,
            },
            value: from.children,
        };
    }
    return {
        type: "html",
        data: {
            hName: from.tagName,
            hProperties: from.properties,
            hChildren: from.children,
        },
        value: "",
    };
};
function capitalize(word) {
    if (word.length === 0) {
        return word;
    }
    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
}
export function formatForAttribute(rawString) {
    return rawString.replace(/\s+/g, "-").toLowerCase();
}
